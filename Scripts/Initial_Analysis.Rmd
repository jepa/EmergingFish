---
title: Matching the Time of Emergence of Transboundary Fish Stocks to Lead Time for
  Policy Response Under Climate Change
author: "Juliano Palacios Abrantes"
date: "09/03/2020"
output:
  word_document: 
    keep_md: yes
  html_document: default
subtitle: Initital analysis
editor_options: 
  chunk_output_type: console
---


```{r setup, eval = T, echo = F, warning = F, message = F, results = 'hide'}

#### READ ME !!! ####
# Run this chunk before knit so you make sure you have all pkgs installed in R

library(MyFunctions)

#### Project's Library
packages <- c(
  "tidyverse",
  "here", # for dbem_import `here()`
  "data.table", #dbem_import `fread()`
  "readxl", # for reading excell files
  "janitor", # for clearing names
  "geosphere", # estimate distances between points `distm()`
  "ggrepel",
  "zoo", # for average mean
  "parallel", # for mclapply,
  "sf", # for mapping
  "st", # for mapping
  "rgdal", #Spatial analysis
  "tools", #Spatial analysis 
  "zeallot", # for Juanito's map
  "gmt" # for estimating distances between points
)

my_lib(packages)

```


# Methods

See methods section of the paper (e.g. Manusript.Rmd)

## Creating Data

Here we re-arrange existing data for the analysis. We have three steps:

1- Set the SAU relations between index and EEZs and include lat long data for each index

2.- Deteremine the centroid of each EEZ and asigned an id to each neighbouring interaction (e.g. Chile and Peru or Canada West Coast and US West Coast) 

3.- Set Neigbouring IDs based on the interactions between neighbouring EEZs for all of those sharing transboundary species

```{r pre_data_creation, eval = F, echo = F}

## ---------------##
#### 1. SAU relations between INDEX and Country's EEZs
## ---------------##

EEZIDs_List <- my_path("G", extra_path = "Spatial/DBEM", name="Updated_EEZList_17June2016.xlsx", read = TRUE) %>% 
  clean_names()

EEZ_CellID <- my_path("G", extra_path = "Spatial/DBEM", name="EEZ_CellID.xlsx", read = TRUE) %>% 
  clean_names()

colnames(EEZ_CellID) <- c("eezid","index")

Lon_Lat_DBEM <- my_path("G", extra_path = "Spatial/DBEM", name="Lon_Lat_DBEM.txt", read = TRUE, header = FALSE)
colnames(Lon_Lat_DBEM) <- c("index","lon","lat")


Index_Code <- EEZIDs_List %>% 
  left_join(EEZ_CellID) %>% 
  rename(eez_name = name) %>% 
  left_join(Lon_Lat_DBEM,
            by = "index")

# Save Index data for future 
write_csv(index_code,
          paste(my_path("G",extra_path = "Spatial/DBEM"),"sau_index_code.csv",sep="")
          )

## ---------------##
#### 2. entroids 
## ---------------##

# Load SAU shapefile name and paths

# The path
Path_SAU <- my_path("G", extra_path = "Spatial/SAU/SAU_Shapefile")

# The File
File_Name <- "SAUEEZ_July2015.shp"

# Load it!
SAU_eez_sf <- st_read(dsn = Path_SAU,
                        layer =file_path_sans_ext(File_Name)
                      ) %>% 
  rename(eez_name = Name) %>% 
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1)

# Get the center poligon of each EEZ for map source/target with st_centroid
coords <- as.data.frame(st_centroid(World_eez_sf)) %>% 
  ungroup() %>% 
  select(eez_name,geometry) %>% 
  separate(col = geometry, into = c("longitude", "latitude"), sep = "\\,") %>% 
  # Manually fix issues
  mutate(
    longitude = ifelse(
      eez_name == "Fiji", 178.065033,
      ifelse(eez_name == "Tuvalu",177.6493,
             ifelse( eez_name == "New Zealand",174.8860,
                     ifelse( eez_name == "USA (Alaska, Subarctic)",-145.8860,
                             ifelse( eez_name == "Brazil",-36.937,longitude
                             )
                     )
             )
      )
    )
  )

# Remove "c()"
coords$longitude <- gsub("\\(","",coords$longitude)
coords$longitude <- gsub("c","",coords$longitude)
coords$latitude <- gsub(")","",coords$latitude)

coords <- coords %>% 
  mutate_at(vars(longitude,latitude),as.numeric)

# Save dataframe so we don't need to run this ewvery time
# write_csv(coords,
#           "eez_centroids.csv")


## ---------------##
#### 3. Set Neigbouring IDs
## ---------------##

# Read transboundary species database from Palacios-Abrantes et al 2020 (FishForVisa)
Transboundary_spp <- read.csv(paste(data_path,"Species/Transboundary_spp.csv",sep="")) %>% 
  clean_names()

# Get id of neighbouring pairs
Neighbours_spp <- Transboundary_spp %>% 
  group_by(eez_name,eez_neighbour) %>% 
  summarise(n=n()) %>% 
  ungroup() %>% 
  select(-n) %>% 
  rownames_to_column("neighbour_id")

# Split dataframes to merge neighbouring ids
df1 <- Neighbours_spp
df2 <- Neighbours_spp
colnames(df2) <- c("neighbour_id", "eez_neighbour", "eez_name")

# Merge neighbouring ids
df_full <- bind_rows(df1, df2) %>% 
  group_by(eez_neighbour,eez_name) %>% 
  summarise(neighbour_id = min(neighbour_id))

# Save dataframe so we don't need to run this every time
# write_csv(df_full, 
#           "Neighbours_eez_id.csv")
    
```

## Estimating Proportion Change

This part of the analysis estimates the Stock Share Ratio and its change under cliamte change under two time frames; early (2030) and mid (2050). Note that 2020 is the average of 2021 to 2040 and mid is the average of 2041 to 2060.


### Fun `EstPropChange`

```{r EstPropChange, eval = T, echo = F}

EstPropChange <- function(taxon_key,
                          year,
                          hist_y,
                          data_type = "Catch",
                          ensamble_list, # expects a list of ensambles to averrage by
                          path,
                          neighbours){
  
  
  # Loads species data for all ensambles
  Spp_Dist <- bind_rows(
    lapply(
      ensamble_list,
      dbem_import,
      taxon_key = taxon_key,
      year = year,
      data_type = data_type,
      path = path
    )
  )
  

  # Filter Species distribution to that of the neighbouring EEZs
  # ------------ #
  # Warning message:
  # Column `eez_name` joining factor and character vector, coercing into character vector 
# ------------ #
  
  suppressWarnings(
    Trans_EEZ <- Transboundary_spp %>% 
      filter(taxon_key %in% Spp_Dist$taxon_key) %>% 
      left_join(index_code,
                by = c("eez_name")
      )
    )
  
  # Get neighbouring id
  Neighbours_List <- Neighbours %>% 
    semi_join(Trans_EEZ,
              by = c("eez_name","eez_neighbour")
    )
  
  # Selecting only the transboundary nature of the species
  Trans_Spp <- Spp_Dist %>%
    filter(index %in% Trans_EEZ$index) %>% 
    left_join(index_code,
              by = "index") %>% 
    filter(eez_name %in% Neighbours_List$eez_name)
  
  # -------------------- #
  # Estimate area index
  # The number of species' cells present within each country's EEZ
  # -------------------- #
  
  #Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(taxon_key,
             eez_name,
             year,
             ensamble) %>% 
    summarise(n_spp_eez = length(unique(index))) %>% 
    left_join(Neighbours_List,
              by = "eez_name")
  
  # Split dataframes to merge latter
  Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      taxon_key,
      Name=eez_name,
      n_spp_eez,
      year,
      ensamble
    )
  
  Neighbour_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      taxon_key,
      n_spp_eez,
      Name=eez_neighbour,
      eez_name,
      year,
      ensamble
    )
  
  # Estimate Area index and % change
  Per_Ghange_D <- full_join(Territory_T,
                            Neighbour_T, 
                            by = c("Name","taxon_key","year","ensamble")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(eez_name = Name,
           eez_neighbour =eez_name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(area_index = n_spp_Country/Spp_Total) %>% 
    # Determine the three time frames for comparrison
    mutate(
      time_step = ifelse(year < hist_y,"historical",
                         ifelse(year >= 2021 & year <= 2040, "early",
                                ifelse(year >= 2041 & year <= 2060, "mid","NA")
                         )
      )
    ) %>%
    filter(time_step != "NA") %>% 
    # Time mean and sd
    ungroup() %>% 
    group_by(taxon_key,ensamble,eez_name,eez_neighbour,time_step) %>% 
    summarise_at(vars("area_index"),
                 c(temporal_mean=mean,
                   temporal_sd=sd)
    ) %>% 
    # Ensamble mean and sd
    group_by(taxon_key,eez_name,eez_neighbour,time_step) %>%
    summarise_at(vars("temporal_mean"),
                 c(ensamble_mean=mean,
                   ensamble_sd=sd),
                 na.rm=T
    )
  
  # --------------- #
  # End function
  # --------------- #
  
  if(nrow(Per_Ghange_D) > 0){
  
  # Save Result
  name <- paste("proportion_",taxon_key,".csv",sep="")
  path_name <- paste(result_path,"Proportion/",name, sep="")
  
  write_csv(Per_Ghange_D,
            path_name)
  
  return(print(paste("analysis done",taxon_key)))
  # return(Per_Ghange_D)
  
  }else{
    print(paste("no result for",taxon_key))
  }
  
  # Or return a df
  return(Per_Ghange_D)
}

# EstPropChange(taxon_key = 600004,
#               year = year_df,
#               hist_y = 2000,
#               data_type = "Catch",
#               ensamble_list = ensamble_list,
#               path = path,
#               neighbours = neighbours)



```


### Proportion Control Panel

```{r Emerging_control_panel, eval = T, echo = F}

## ----------------- ##
# Data needed for estimating year of emergence
## ----------------- ##

# SAU relations between INDEX and Country's EEZs (see chunk 3)
index_code <- read_csv(paste(data_path,"Spatial/sau_index_code.csv",sep=""))

# Neighbour list and their respective id (see chunk 3)
Neighbours <- read_csv(paste(data_path,"Spatial/Neighbours_eez_id.csv",sep="")) %>% clean_names()

# Transboundary species and their sharing EEZs (see Palacios-Abrantes et al; FishForVisa)
Transboundary_spp <- read_csv(paste(data_path,"Species/Transboundary_spp.csv",sep="")) %>% 
  clean_names() %>% 
  select(-x1)

## ----------------- ##
# Global variables
## ----------------- ##

# Year timeframe
year_df <- tibble(year =  c(seq(1951,2000,1), seq(2001,2099,1)),
                  time_period = c(rep("historic", 50), rep("future", 99))
                  )

# Data path
path = DBEM_path

# List of ensamble members
ensamble_list <- seq(102,103,1) # for testing
# ensamble_list <- seq(102,111,1)

#  List os species
spp_list <- unique(Transboundary_spp$taxon_key)[1:2]

```

### Proportion routine

```{r Proportion_routine, eval = T, echo = F}

####_______________________ ####
# Estimating proportion change
####_______________________ ####

t_start <- Sys.time()

mclapply(
  spp_list,
  EstPropChange,
  year <- year_df,
  data_type <- "Catch",
  ensamble_list = ensamble_list,
  path = DBEM_path,
  neighbours = Neighbours
)

t_end <- Sys.time()-t_start;t_end

# Hall 1000 ran it in 5.33 hours

```

## Estimating emerging year

This rutine estimates the time (e.g. year) in which the changes in stock share ratio is more likely to happen based on historical variations (e.g. model noise) and future trends (e.g signal). This result uses teh average of the 10 ensamble members

### Fun `GetCentroids` 

This function estimates the distance between the centroid of each neighbouring EEZ and the distribution of the species along both EEZs. We define species centroid as the tile with the highest value of maimum catch potential from all of the species distribution in each year.

```{r GetCentroids, eval = T, echo = F}

GetCentroids <- function(taxon_key,
                         year, 
                         data_type = "Catch",
                         ensamble, 
                         path,
                         Neighbours,
                         eez_centroid){
  
  # ----------------- #
  # Get model data from spps for one ensamble
  #  ---------------- #
  
  Spp_Dist <- dbem_import(
    taxon_key = taxon_key,
    year = year,
    data_type = data_type,
    ensamble = ensamble,
    path = path
  )
  
  # ----------------- #
  # Extra step 
  # ----------------- #
  
  #### Creates a data to control computational time
  if(file.exists("~/Desktop/spp_df.csv") == FALSE){
    spp_df <- tibble() %>% 
      write_csv(.,
                "~/Desktop/spp_df.csv")
  }
  
  suppressMessages(
    spp_df <- read_csv("~/Desktop/spp_df.csv")
  )
  spp_df <- tibble(taxon_key,
                   ensamble) %>% 
    bind_rows(spp_df) %>% 
    write_csv(.,
              "~/Desktop/spp_df.csv")
  
  # ----------------- #
  # Estimate distance between centroids
  # ----------------- #
  
  # Filter only the transboundary nature of the species 
  Trans_Spp <- Spp_Dist %>%
    left_join(index_code,
              by= "index") %>% 
    filter(!is.na(value)) %>% 
    semi_join(Transboundary_spp, # filter only transboundary cases
              by = c("taxon_key","eez_name")
    )
  
  # ----------------- #
  # Extra step 
  # ----------------- #
  # Controls for cases with no-data
  nr <- nrow(Trans_Spp)
  if(nr > 0){
    
    # Filter eez by those transboundary
    unique_eez <- unique(Trans_Spp$eez_name)
    
    Neighbours_combo <- Neighbours %>% 
      filter(eez_name %in% unique_eez,
             eez_neighbour %in% unique_eez)
    
    # Get the centroid of each country
    EEZ_centroid <- eez_centroid %>% 
      filter(eez_name %in% Trans_Spp$eez_name) %>% 
      mutate(taxon_key = taxon_key)
    
    # ----------------- #
    # Centroid function
    # ----------------- #
    
    # This function estimates the distance of each neighbouring EEZ
    # It uses Ids wich is a pre-determine identifier of neighbouring
    # EEZs. Fo example Peru and Chile have Id = 167, and viceversa
    
    CentroidsFx <- function(Ids){  
      
      # Filter data by Ids
      EEZ_ids <- Neighbours_combo %>% 
        filter(neighbour_id == Ids)
      
      Sub_Trans_Spp <- Trans_Spp %>% 
        filter(eez_name %in% EEZ_ids$eez_name)
      
      Sub_EEZ_centroid <- EEZ_centroid %>% 
        filter(eez_name %in% EEZ_ids$eez_name)
      
      # Centroid is defined as the tile with the higest species value
      Centroids <- Sub_Trans_Spp %>% 
        left_join(EEZ_ids, by = "eez_name") %>% 
        group_by(taxon_key,year,ensamble,neighbour_id) %>%  # for whole distribution
        top_n(1,value) %>% 
        distinct(value,year, .keep_all = TRUE) %>%  # removes duplicates when tile is in between EEZs
        left_join(Sub_EEZ_centroid, by = "taxon_key") %>%
        select(eez_name =eez_name.y, everything() ,-eez_name.x) %>% 
        # Estimate distances between spp centroid and EEZ centroid
        mutate(
          distance = geodist(longitude, # eez longitude
                             latitude,  # eez latitude
                             lon,  # species longitude
                             lat, # species latitude
                             units="km")
        ) %>% 
        select(taxon_key,eez_name,neighbour_id,ensamble,year,distance)
      
      return(Centroids)
      
    }
    
    # Determine the ids
    Ids <- unique(Neighbours_combo$neighbour_id)
    
    # Run sub-function
    Centroids_Data <- bind_rows(
      lapply(Ids,CentroidsFx)
    )
    
  }else{
    # In case there's no data
    Centroids_Data <- tibble()
    
  }
  
  return(Centroids_Data)
  
}



GetCentroids(taxon_key = 600004,
             year = year_df,
             # data_type = data,
             ensamble = 102,
             path = path,
             Neighbours = Neighbours,
             eez_centroid = eez_centroid
             )

```

### Fun `TransIndex`

This functions takes on `GetCentroids` function and estimates the TransIndex (*TI*) for each pair of neighbouring countries. Presents a 10 years average of the results

$$TI =(\frac{D_{A,y}}{sd(D_{A,h})} - \frac{D_{B,y}}{sd(D_{B,h)}})^2$$

The year of emergece is defined as the first year where the trend is larger than the 95% CI of the historic variation.


```{r TransIndex, eval = T, echo = T}

TransIndex <- function(Centroids, # Expecting the results from the GetCentroids function
                       Ids, # A numeric value representing a neighbouring interaction
                       Hist_y = 2000){ # The LAST year of Historical data
  
  # Filter data by neighbouring ID
  Centroids_id <- Centroids %>% 
    filter(neighbour_id %in% Ids)
  
  EEZ_ids <- Neighbours %>% 
    filter(neighbour_id %in% Ids)
  
  # Historical mean and sd of distance
  historical <- Centroids_id %>%
    filter(year <= Hist_y) %>% 
    ungroup() %>%
    group_by(taxon_key,ensamble,eez_name,neighbour_id) %>%
    summarise_at(vars("distance"),
                 c(hd_temp_mean=mean,
                   hd_temp_sd=sd)
    )
  
  # Future results
  future <- Centroids_id %>% 
    filter(year > Hist_y)
  
  # Transboundary Index
  Trans_index <- Centroids_id %>% 
    left_join(historical,
              by = c("taxon_key","eez_name","ensamble","neighbour_id")
    ) %>%
    # Re arrenging table for mutate
    gather("variable","value",distance:hd_temp_sd) %>%
    ungroup()
  
  # Get unique eezs
  Unique_EEZs <- unique(Trans_index$eez_name)
  
  
  Partial <- Trans_index %>% 
    mutate(
      names = ifelse(eez_name ==Unique_EEZs[1],paste("Country_A",variable,sep="_"),paste("Country_B",variable,sep="_"))
    ) %>%
    select(-eez_name,-variable) %>%
    spread(names,value) %>% 
    # mutate index
    mutate(
      trans_index = (Country_A_distance/Country_A_hd_temp_sd - Country_B_distance/Country_B_hd_temp_sd)^2
    ) %>% 
    # Ten years average of results
    group_by(taxon_key,ensamble,neighbour_id) %>% 
    mutate(RMean = rollmean(x = trans_index, 
                            10, 
                            align = "right", 
                            fill = trans_index)
    ) %>% 
    filter(year > 1960) %>% 
    select(taxon_key,neighbour_id,year,ensamble,trans_index,RMean)
  
  # Average of 10 years mean of ensamble members results
  mean_sd_index <- Partial %>% 
    group_by(taxon_key,year,neighbour_id) %>% 
    summarise_at(vars("RMean"),
                 c(trend=mean,
                   ensamble_sd=sd)
    )
  
  # Estimate noice from ensamble members
  historic_sd <- mean_sd_index %>% 
    filter(year < Hist_y) %>% 
    group_by(taxon_key) %>% 
    summarise_at(vars("trend"),
                 c(hist_mean=mean,
                   noise=sd)
    )
  
  
  # Plot the result, bruh
  # ggplot() +
  #   geom_line(data = mean_sd_index,
  #             aes(
  #               x = year,
  #               y = trend
  #             )
  #   ) +
  #   geom_ribbon(data = mean_sd_index,
  #               aes(x=year,
  #                   ymin=historic_sd$hist_mean-historic_sd$noise,
  #                   ymax=historic_sd$hist_mean+historic_sd$noise),
  #               alpha = 0.5,
  #               fill = "grey50"
  #   ) +
  #   geom_line(data = mean_sd_index,
  #             aes(
  #               x = year,
  #               y = historic_sd$hist_mean
  #             ),
  #             colour = "grey50"
  #   ) +
  #   geom_point(data = subset(mean_sd_index, trend > (historic_sd$hist_mean+historic_sd$noise) | trend < (historic_sd$hist_mean-historic_sd$noise)),
  #              aes(
  #                x = year,
  #                y = trend,
  #                colour = "red",
  #              ),
  #              shape = 1,
  #              size = 3
  #   ) +
  #   geom_vline(xintercept = 2000,colour="blue",alpha = 0.5) +
  #   theme_classic()
  
  # Identifies the year of emergence
  Final_Result <- mean_sd_index %>%
    filter(year > Hist_y,
           trend > (historic_sd$hist_mean+historic_sd$noise) |
             trend < (historic_sd$hist_mean-historic_sd$noise)
    ) %>%
    group_by(taxon_key,neighbour_id) %>%
    summarise(emerging_yr= min(year)) %>%
    left_join(EEZ_ids) %>%
    ungroup() %>%
    select(taxon_key,eez_name,eez_neighbour,emerging_yr)
  
  return(Final_Result)
}


```

### Fun `GetTransIndex`

This is the last function of the emerging year evaluation. It was made so we could run the analysis per each species. The function function simply runs the functions `GetCentroids` by ensabmble member and then `TransIndex` by pairing EEZ. Thus, with this function we run the whole set by species * paired EEZ * ten ensamble members. 

```{r GetTransIndex, eval = T, echo = T}
  
GetTransIndex <- function(taxon_key,
                            year,
                          Hist_y,
                            data_type = "Catch",
                            path,
                            ensamble_list,
                            Neighbours,
                            eez_centroid){
    
    # First step
    # Call Get centroids fucntion for centroids data per ensamble
    Step_one <- bind_rows(
      lapply(ensamble_list,
             GetCentroids,
             taxon_key = taxon_key,
             year = year,
             data_type = data_type,
             path = path,
             Neighbours = Neighbours,
             eez_centroid = eez_centroid)
    )
    
    # Set the different neighbouring pairs
    Ids <- unique(Step_one$neighbour_id)
    
    # Second Step
    # Get the transboudary index based on all centroids
    Step_two <- bind_rows(
      lapply(Ids,
             TransIndex,
             Hist_y = Hist_y,
             Centroid = Step_one)
    )
    
    
    return(Step_two)
  }
  
  
  # GetTransIndex(
  #   taxon_key = 600004,
  #   ensamble_list = ensamble_list[1:2],
  #   year = year,
  #   Hist_y = 2000,
  #   data_type = "Abd",
  #   path = path,
  #   Neighbours = Neighbours,
  #   eez_centroid = eez_centroid
  # )


  # spp_list <- c(600004, 600245)
  # 
  #  test <- bind_rows(
  #   lapply(spp_list,
  #          GetTransIndex,
  #          year = year,
  #          data_type = "Catch",
  #          path = path,
  #          Neighbours = Neighbours,
  #          eez_centroid = eez_centroid,
  #          ensamble_list = ensamble_list
  #   )
  # )
  # 
    
```

### Emerging Control Panel

```{r Emerging_control_panel, eval = T, echo = T}

## ----------------- ##
# Data needed for estimating year of emergence
## ----------------- ##

# SAU relations between INDEX and Country's EEZs (see chunk 3)
index_code <- read_csv(paste(data_path,"Spatial/sau_index_code.csv",sep=""))

# EEZ list and their centroid of distribution (see chunk 3)
eez_centroid <- read.csv(paste(data_path,"Spatial/eez_centroids.csv", sep = ""), header=TRUE)

# Neighbour list and their respective id (see chunk 3)
Neighbours <- read.csv(paste(data_path,"Spatial/Neighbours_eez_id.csv",sep="")) %>% clean_names()

# Transboundary species and their sharing EEZs (see Palacios-Abrantes et al; FishForVisa)
Transboundary_spp <- read.csv(paste(data_path,"Species/Transboundary_spp.csv",sep="")) %>% 
  clean_names()

## ----------------- ##
# Global variables
## ----------------- ##

# Year timeframe
year_df <- tibble(year =  seq(1951,2099,1))

# Last year of "historic" data
Historic_year = 2000

# Data path
path = DBEM_path

# List of ensamble members
ensamble_list <- seq(102,103,1) # for testing
# ensamble_list <- seq(102,111,1)

#  List os species
spp_list <- unique(Transboundary_spp$taxon_key)[1:2]

```

### Emerging Routine

```{r Emerging_routine, eval = F, echo = F}

####_______________________ ####
# Estimating year of eergence
####_______________________ ####

t_start <- Sys.time()

suppressMessages(
  suppressWarnings(
    Emerging_result <- bind_rows(
      mclapply(spp_list[1],
               GetTransIndex,
               year = year_df,
               Hist_y = Historic_year,
               data_type = "Catch",
               ensamble_list = ensamble_list,
               path = path,
               Neighbours = Neighbours,
               eez_centroid = eez_centroid
      )
    )
  )
)


t_end <- Sys.time()-t_start;t_end

write_csv(Emerging_result,
          "~/Desktop/Test.csv")

# Version 1 (embeded loop) <- 3.01
# Version 2 (embeded lapply) <- 2.71
# Version 3 (embeded mclapply) <- 1.597311 mins
# Version 4 (embeded mclapply) + mclapply in spp <- 1.597311 mins

```

# Results

## Percentage Change

This results only shows the average percentage change in proportion of all speecies within an EEZ without relationship with neighbours

### Functions and Data needed

#### Fun `SummaryProp`

This function estimates the total change in MCP proportion of each species for each EEZ. It looses the connection with neighbours as you only know for x species houw much is the proportion changing.

```{r fun_SummaryProp, eval = F, echo =F}

SummaryProp <- function(taxon_key,links="NA"){
  
  # Reads taxon data
  proportion_data <- fread(paste(result_path,"Proportion/","proportion_",taxon_key,".csv", sep=""))
  
  if(links == "y"){
    # summarizes by country and neighbour
    country_summary <- proportion_data %>% 
      group_by(taxon_key,eez_name,eez_neighbour,time_step) %>% 
      summarise(
        mean_spp = mean(ensamble_mean,na.rm=T) # average spp change from all countries sharing
      )
    
  }else{
    # summarizes by country
    country_summary <- proportion_data %>% 
      group_by(taxon_key,eez_name,time_step) %>% 
      summarise(
        mean_spp = mean(ensamble_mean,na.rm=T) # average spp change from all countries sharing
      )
    }
  
  return(country_summary)
}

```


#### Fun `EEZProp`

The next step is to summarize all species per eez so our results shows average change of all species within an EEZ towards a neighbour

```{r fun_EEZProp, eval = F, echo = F}

EEZProp <- function(taxon_list,links="NA"){

 spp <- bind_rows(
   lapply(taxon_list,SummaryProp,links)
   )
 
 if(links == "y"){
   
   eez_summary <- spp %>% 
     group_by(eez_name,eez_neighbour,time_step) %>% 
     summarise(
       n_spp = n(),
       min_spp = min(mean_spp,na.rm=T),
       max_spp = max(mean_spp,na.rm=T),
       sd_spp = sd(mean_spp,na.rm=T), # for some weird reason it wont work if the order is fliped
       mean_spp = mean(mean_spp,na.rm=T)
     ) %>% 
     select(eez_name:max_spp,mean_spp,sd_spp)
   
 }else{
 
   eez_summary <- spp %>% 
   group_by(eez_name,time_step) %>% 
   summarise(
     n_spp = n(),
     min_spp = min(mean_spp,na.rm=T),
     max_spp = max(mean_spp,na.rm=T),
     sd_spp = sd(mean_spp,na.rm=T), # for some weird reason it wont work if the order is fliped
     mean_spp = mean(mean_spp,na.rm=T)
   ) %>% 
   select(eez_name:max_spp,mean_spp,sd_spp)
 
 
 }
 
 return(eez_summary)

}

```

#### Fun `PropChange`

Finally, we estimate the average proportion change of all species within each eez

```{r fun_PropChange, eval = F, echo =F}

PropChange <- function(taxon_list,links="NA"){

 eez <- EEZProp(taxon_list,links)
 
 proportion_change <- eez %>% 
   gather("variable","value",n_spp:sd_spp) %>% 
   spread(time_step,value) %>% 
   mutate_at(vars(
     "per_mid" = mid,
     "per_end" = n_end),
            funs(round((((.-historical)/.))*100,2))
   )
 
 return(proportion_change)

}

```

### Run Results Analysis

```{r fun_PropChange, eval = F, echo =F}

# Get taxon list
Taxon_List <- list.files(paste(result_path,"/Proportion/",sep=""))

# clean names for function
Taxon_List <- gsub(".*_","",Taxon_List) 
Taxon_List <- gsub("\\..*","",Taxon_List)

# Run results
Proportion_Results <- PropChange(Taxon_List, links="y") %>% 
  mutate(per_mid =ifelse(per_mid >= 25, 25,
                           ifelse(per_mid <= -25,-25,per_mid)
                           )
         )

# View(results)

### Load Data

# Load SAU shapefile name and paths

# The path
path_world <- paste(data_path,"Spatial/SAU_Shapefile/",sep="")

# The File
fnam_world <- "SAUEEZ_July2015.shp"

# Load it!
World_eez_sf <- st_read(dsn = path_world,
                    layer =file_path_sans_ext(fnam_world)) %>% 
  rename(eez_name = Name) %>% 
  st_transform(crs = 4326) %>% # 4326
  st_simplify(preserveTopology = TRUE, dTolerance = 0.1)



# Call world map from natural earth
World_map <- rnaturalearth::ne_countries(scale = 'small', returnclass = c("sf"))

eez_centroid <- read_csv(paste(data_path,"Spatial/eez_centroids.csv", sep = ""))

```

### Fig.Percentage Change Map

```{r fig_map_per, eval = F, echo =F}

World_sf %>% 
  left_join(results,
            by = "eez_name") %>% 
  filter(variable %in% c("mean_spp")#,
         # eez_name %in% c("Peru","Chile","Ecuador","Argentina")
         ) %>% 
  ggplot() +
  geom_sf(
    aes(
      fill = per_mid
    )
  ) + 
  geom_sf(data=country10_sf) +
  scale_fill_gradient2("Average Change in\nStock-Share Ratio (%)\nBy Mid Century") +
  ggtheme_map() +
  ggsave("per_mid.png",
         width = 10,
         height = 6,
         units = "in"
  )

```


### Fig. Netowrk

```{r fig_map_Juan, eval = F, echo =F}
# Figure made thanks to Juanito!
# http://jsmayorga.com/post/mapping-the-global-network-of-transnational-fisheries/

# Prepare data from results
Data <- results %>% 
  # get coords for sources
  left_join(eez_centroid,
            by = "eez_name") %>%
  rename(source = eez_name,
         start_lon = longitude,
         start_lat = latitude,
         eez_name=eez_neighbour) %>% 
  # get coords for targets
  left_join(eez_centroid,
            by = "eez_name") %>% 
  rename(target = eez_name,
         end_lon = longitude,
         end_lat = latitude) %>% 
  ungroup() %>% 
  # Plot miscs
  mutate(
    per_mid = ifelse(is.na(per_mid),0,per_mid)
  ) %>% 
  drop_na() %>%
  filter(
    variable == "mean_spp"#,
    # source %in% c("Brazil","Argentina","Chile","Peru","Uruguay")
  )

# Convert to data to spatial
network_data_sf <- Data %>%
  select(start_lon, start_lat, end_lon, end_lat) %>% 
  purrr::transpose() %>% 
  purrr::map(~ matrix(flatten_dbl(.), nrow = 2, byrow = TRUE)) %>% 
  purrr::map(st_linestring) %>%
  st_sfc(crs = 4326) %>%
  st_sf(geometry = .)%>%
  bind_cols(Data) %>%
  select(everything(), geometry) %>% 
  # Set circles ('cus the world is not flat!)
  st_segmentize(units::set_units(100, km)) %>% 
  mutate(geometry = (geometry + c(180,90)) %% c(360) - c(180,90)) %>% 
  st_wrap_dateline(options = c("WRAPDATELINE=YES",  "DATELINEOFFSET=180"), quiet = TRUE) %>% 
  sf::st_sf(crs = 4326)

#  unpack the coordinates of each feature 
coord_data <- as.data.frame( st_coordinates(st_cast(network_data_sf,"MULTILINESTRING")$geometry))

c(network_data_sf$line_id, network_data_sf$coords) %<-% (
  coord_data %>% 
    rename(subline_id = L1) %>%   
    nest(-L2)
)

# Create data path for line connections
paths <- network_data_sf %>% 
  sf::st_set_geometry(NULL) %>% 
  unnest() %>% 
  mutate_at(vars(X,Y), round,2)

# Plot it!

gc()# clean ram
x <- ggplot() +
  geom_sf(data = subset(World_map, sovereignt != "Antarctica"), size = 0.1, fill = "gray90", col = "gray90") +
  geom_sf(data = World_eez_sf, size = 0.1, fill = "white", col = "gray70") +
  geom_point(data = subset(Data, per_mid < 0),
             aes(start_lon,
                 start_lat,
                 col = per_mid),
             size = 0.05,
             col = "gray30",
             shape = 20,
             stroke = 1.5) +
  geom_path(data = subset(paths, per_mid > 0),
            aes(X, Y,
                group = interaction(line_id,subline_id),
                col = per_mid
            ),
            size = 0.3,
            arrow = arrow(length = unit(0.009, "npc"),
                          ends = "first"),
            show.legend = NA) +
  ggtheme_map() +
  scale_colour_viridis(
    name="Average Gain of\nStock-Share Ratio (%)",
    limits = c(0,25),
    breaks = seq(0,25,5),
    # option="magma",
    direction = 1
  ) +
  ggsave("figure_connectionsc.png",
         width = 10,
         height = 6,
         units = "in"
  )

```

## Troubleshooting

### Weird connections from Australia

```{r fig_map_Juan, eval = F, echo =F}

##_----------------------- #
# Checking on China and Indonesia
# Probably due to dispute territories

Neighbours <- read_excel(paste(data_path,"Spatial/EEZ_Neighbour_List.xlsx",sep="")) %>% 
  clean_names()

# 
# Neighbours %>% 
#   filter(eez_name == "China") %>% 
#   pull(eez_neighbour) %>% 
#   unique()

##_----------------------- #


# Get the center poligon of each EEZ for map source/target
coords <- as.data.frame(st_centroid(World_eez_sf)) %>% 
  ungroup() %>% 
  select(eez_name,geometry) %>% 
  separate(col = geometry, into = c("longitude", "latitude"), sep = "\\,") %>% 
  # Manually fix issues
  mutate(
    longitude = ifelse(
      eez_name == "Fiji", 178.065033,
      ifelse(eez_name == "Tuvalu",177.6493,
             ifelse( eez_name == "New Zealand",174.8860,
                     ifelse( eez_name == "USA (Alaska, Subarctic)",-145.8860,longitude
                     )
             )
      )
    )
  )

# Remove "c()"
coords$longitude <- gsub("\\(","",coords$longitude)
coords$longitude <- gsub("c","",coords$longitude)
coords$latitude <- gsub(")","",coords$latitude)

coords <- coords %>% 
  mutate_at(vars(longitude,latitude),as.numeric)

# Prepare data from results
Test_Data <- results %>% 
  # get coords for sources
  left_join(coords,
            by = "eez_name") %>%
  rename(source = eez_name,
         start_lon = longitude,
         start_lat = latitude,
         eez_name=eez_neighbour) %>% 
  # get coords for targets
  left_join(coords,
            by = "eez_name") %>% 
  rename(target = eez_name,
         end_lon = longitude,
         end_lat = latitude) %>% 
  ungroup() %>% 
  # Plot miscs
  mutate(
    per_mid = ifelse(is.na(per_mid),0,per_mid)
  ) %>% 
  drop_na() %>% 
  filter(
    # per_mid >= 20,
    variable == "mean_spp",
  )


# Convert to data to spatial
network_data_sf <- Test_Data %>%
  select(start_lon, start_lat, end_lon, end_lat) %>% 
  purrr::transpose() %>% 
  purrr::map(~ matrix(flatten_dbl(.), nrow = 2, byrow = TRUE)) %>% 
  purrr::map(st_linestring) %>%
  st_sfc(crs = 4326) %>%
  st_sf(geometry = .)%>%
  bind_cols(Test_Data) %>%
  select(everything(), geometry) %>% 
  # Set circles ('cus the world is not flat!)
  st_segmentize(units::set_units(100, km)) %>% 
  mutate(geometry = (geometry + c(180,90)) %% c(360) - c(180,90)) %>% 
  st_wrap_dateline(options = c("WRAPDATELINE=YES",  "DATELINEOFFSET=180"), quiet = TRUE) %>% 
  sf::st_sf(crs = 4326)

#  unpack the coordinates of each feature 
coord_data <- as.data.frame( st_coordinates(st_cast(network_data_sf,"MULTILINESTRING")$geometry))

c(network_data_sf$line_id, network_data_sf$coords) %<-% (
  coord_data %>% 
    rename(subline_id = L1) %>%   
    nest(-L2)
)

# Create data path for line connections
paths <- network_data_sf %>% 
  sf::st_set_geometry(NULL) %>% 
  unnest() %>% 
  mutate_at(vars(X,Y), round,2)

# Plot it!

country <- c("Fiji","Solomon Isl.","Tuvalu")

ggplot() +
  geom_sf(
    # data = subset(world_map,name %in% country),
    data = world_map,
    size = 0.1, fill = "gray90", col = "gray90") +
  geom_sf(
    # data = subset(World_eez_sf, eez_name %in% country),
    data = World_eez_sf,
    size = 0.1, fill = "white", col = "gray70") +
  geom_point(data = Test_Data,
             # data = subset(Test_Data, source %in% country & target %in% source),
             aes(start_lon,
                 start_lat,
                 col = per_mid),
             size = 0.1,
             col = "black",
             # shape = 21,
             stroke = 1.5) +
  geom_path(data = paths,
            # data = subset(paths, source %in% country),
            aes(X, Y,
                group = interaction(line_id,subline_id),
                col = per_mid
            ),
            size = 0.3,
            arrow = arrow(length = unit(0.009, "npc")),
            show.legend = NA) +
  # geom_sf_text(data = subset(World_eez_sf, eez_name %in% country),
  #              aes(label =eez_name),
  #              size = 2) +
  # geom_text(data = subset(Test_Data, source %in% country),
  #              aes(start_lon,
  #                start_lat,
  #                label = paste(source,"to",target)
  #              ),
  #              size = 2) +
  # geom_text_repel(data = Test_Data,
  #   aes(start_lon,
# start_lat,
# label = paste(source,"to",target)
# )
# )+
ggtheme_map() +
  scale_colour_gradientn("Gain of Stock-Share Ratio (%)",
                         colours = wesanderson::wes_palette("Zissou1", 100, type = "continuous"),
                         limits = c(0,25),
                         breaks = seq(0,25,5)
  )

```


# Old Code


```{r TransIndex, eval = F, echo = F}

TransIndex <- function(Spp,year, data_type = "Catch",ensamble_list,path,Neighbours,eez_centroid){
  
  # ----------------- #
  # Get Species Centrodis
  #  ---------------- #
  
  # Get model data from spps
  Spp_Dist <- bind_rows(
    lapply(
      ensamble_list,
      dbem_import,
      taxon_key = Spp,
      year = year,
      data_type = data_type,
      path = path
    )
  )
  
  
  #### Control for Spp id so I can fix problems
  
if(file.exists("~/Desktop/spp_df.csv") == FALSE){
  spp_df <- tibble() %>% 
    write_csv(.,
            "~/Desktop/spp_df.csv")
}

  suppressMessages(
    spp_df <- read_csv("~/Desktop/spp_df.csv")
  )
  spp_df <- tibble(Spp) %>% 
    bind_rows(spp_df) %>% 
    write_csv(.,
              "~/Desktop/spp_df.csv")
  
  
  #____________ Selecting only the transboundary nature of the species _________ #
  Trans_Spp <- Spp_Dist %>%
    left_join(index_code,
              by= "index") %>% 
    filter(!is.na(value)) %>% 
    semi_join(Transboundary_spp, # filter only transboundary cases
              by = c("taxon_key","eez_name")
    )
  
  # Step
  nr <- nrow(Trans_Spp)
  if(nr > 0){
    

    # Filter eez by those transboundary
  unique_eez <- unique(Trans_Spp$eez_name)
  
  Neighbours_combo <- Neighbours %>% 
    filter(eez_name %in% unique_eez,
           eez_neighbour %in% unique_eez)
    
    
    # Get the centroid of each country
    EEZ_centroid <- eez_centroid %>% 
      filter(eez_name %in% Trans_Spp$eez_name) %>% 
      mutate(taxon_key = Spp)
    
    
    Ids <- unique(Neighbours_combo$neighbour_id)
    
  corefx <- function(Ids){  
    
      EEZ_ids <- Neighbours_combo %>% 
        filter(neighbour_id == Ids)
      
      Sub_Trans_Spp <- Trans_Spp %>% 
        filter(eez_name %in% EEZ_ids$eez_name)
      
      Sub_EEZ_centroid <- EEZ_centroid %>% 
        filter(eez_name %in% EEZ_ids$eez_name)
      
      # Centroid is defined as the tile with the higest species value
      Centroids <- Sub_Trans_Spp %>% 
        left_join(EEZ_ids, by = "eez_name") %>% 
        group_by(taxon_key,year,ensamble,neighbour_id) %>%  # for whole distribution
        top_n(1,value) %>% 
        distinct(value,year, .keep_all = TRUE) %>%  # removes duplicates when tile is in between EEZs
        left_join(Sub_EEZ_centroid, by = "taxon_key") %>%
        select(eez_name =eez_name.y, everything() ,-eez_name.x)
      
      # Estimate distances between spp centroid and EEZ centroid
      Distance_Data <- Centroids %>%
        rename(
          catch_lon = lon,
          catch_lat = lat,
          eez_lon = longitude,
          eez_lat= latitude
        ) %>% 
        # Estimate the distance between centriods
        mutate(
          distance = geodist(eez_lon, eez_lat, catch_lon, catch_lat, units="km")
        ) %>% 
        select(taxon_key,eez_name,neighbour_id,ensamble,year,distance)
      
      # Historical mean and sd of distance
      historical <- Distance_Data %>%
        filter(year <= 2000) %>%
        ungroup() %>%
        group_by(taxon_key,ensamble,eez_name,neighbour_id) %>%
        summarise_at(vars("distance"),
                     c(hd_temp_mean=mean,
                       hd_temp_sd=sd)
        )
      
      
      # Future results
      future <- Distance_Data %>% 
        filter(year > 2000)
      
      # Transboundary Index
      Trans_index <- Distance_Data %>% 
        left_join(historical,
                  by = c("taxon_key","eez_name","ensamble","neighbour_id")
        ) %>%
        # Re arrenging table for mutate
        gather("variable","value",distance:hd_temp_sd) %>%
        ungroup()
      
      
      Partial <- Trans_index %>% 
        mutate(
          names = ifelse(eez_name ==Sub_EEZ_centroid$eez_name[1],paste("Country_A",variable,sep="_"),paste("Country_B",variable,sep="_"))
        ) %>%
        select(-eez_name,-variable) %>%
        spread(names,value) %>% 
        # mutate index
        mutate(
          trans_index = (Country_A_distance/Country_A_hd_temp_sd - Country_B_distance/Country_B_hd_temp_sd)^2
        ) %>% 
        group_by(taxon_key,ensamble,neighbour_id) %>% 
        mutate(RMean = rollmean(x = trans_index, 
                                10, 
                                align = "right", 
                                fill = trans_index)
        ) %>% 
        filter(year > 1960) %>% 
        select(taxon_key,neighbour_id,year,ensamble,trans_index,RMean)
      
      # Average of 10 years mean of ensamble members results
      mean_sd_index <- Partial %>% 
        group_by(taxon_key,year,neighbour_id) %>% 
        summarise_at(vars("RMean"),
                     c(trend=mean,
                       ensamble_sd=sd)
        )
      
      # Estimate noice from ensamble members
      historic_sd <- mean_sd_index %>% 
        filter(year < 2000) %>% 
        group_by(taxon_key) %>% 
        summarise_at(vars("trend"),
                     c(hist_mean=mean,
                       noise=sd)
        )
      
      
      # Plot the result, bruh
      # ggplot() +
      #   geom_line(data = mean_sd_index,
      #             aes(
      #               x = year,
      #               y = trend
      #             )
      #   ) +
      #   geom_ribbon(data = mean_sd_index,
      #               aes(x=year,
      #                   ymin=historic_sd$hist_mean-historic_sd$noise,
      #                   ymax=historic_sd$hist_mean+historic_sd$noise),
      #               alpha = 0.5,
      #               fill = "grey50"
      #   ) +
      #   geom_line(data = mean_sd_index,
      #             aes(
      #               x = year,
      #               y = historic_sd$hist_mean
      #             ),
      #             colour = "grey50"
      #   ) +
      #   geom_point(data = subset(mean_sd_index, trend > (historic_sd$hist_mean+historic_sd$noise) | trend < (historic_sd$hist_mean-historic_sd$noise)),
      #              aes(
      #                x = year,
      #                y = trend,
      #                colour = "red",
      #              ),
      #              shape = 1,
      #              size = 3
      #   ) +
      #   geom_vline(xintercept = 2000,colour="blue",alpha = 0.5) +
      #   theme_classic()
      
      # #     
      Final_Result <- mean_sd_index %>%
        filter(year > 2000,
               trend > (historic_sd$hist_mean+historic_sd$noise) |
                 trend < (historic_sd$hist_mean-historic_sd$noise)
        ) %>%
        group_by(taxon_key,neighbour_id) %>%
        summarise(emerging_yr= min(year)) %>%
        left_join(EEZ_ids) %>%
        ungroup() %>%
        select(taxon_key,eez_name,eez_neighbour,emerging_yr)
      
      
      # if(i == 1){
      #   f_df <- Final_Result
      # }else{
      #   f_df <- bind_rows(f_df,Final_Result)
      # }
    return(Final_Result)
      }
    
  
  x <- bind_rows(
    mclapply(Ids,corefx)
  )
    # return(f_df)
    
  }else{
    
    print("no share data")
    
    x <- tibble(
      taxon_key = Spp,
      eez_name = NA,
      emerging_yr = NA
    )
    
  }
  
  return(x)

}

 
#  #One spp works 
# suppressMessages(
# TransIndex(Spp = 600006,
#              year,
#              data_type = "Catch",
#              ensamble_list,
#              path,
#              Neighbours = Neighbours,
#              eez_centroid)
# Multiple spp

# spp_list <- c(600004,
#               600005,
#               600245,
#               600006
#               )
# 
# suppressMessages(
#   suppressWarnings(
#     Test <- bind_rows(
#       lapply(spp_list,
#              TransIndex,
#              year,
#              data_type = "Catch",
#              ensamble_list,
#              path,
#              Neighbours,
#              eez_centroid
#       )
#     )
#   )
# )


```
