---
title: Matching the Time of Emergence of Transboundary Fish Stocks to Lead Time for
  Policy Response Under Climate Change
author: "Juliano Palacios Abrantes"
date: "09/03/2020"
output:
  word_document: default
  html_document: default
subtitle: Initital analysis
editor_options: 
  chunk_output_type: console
---


```{r Ch3_setup, eval = T, echo=F, warning=F,message=F, results='hide'}

#### READ ME !!! ####
# Run this chunk before knit so you make sure you have all pkgs installed in R

ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE,repos = "http://cran.us.r-project.org")
  sapply(pkg, require, character.only = TRUE)
}


#### Library ####
packages <- c(
  "tidyverse",
  "here", # for dbem_import `here()`
  "data.table", #dbem_import `fread()`
  "readxl", # for reading excell files
  "janitor", # for clearing names
  "geosphere", # estimate distances between points `distm()`
  "ggrepel",
  "zoo"
)

ipak(packages)


# Set paths depending on machine Beast (jepa88), "carmelia" or Hall1000
if(Sys.info()[7] == "jepa88"){
  data_path <- "Z:/DATA/DBEM/"
}
if(Sys.info()[7] == "carmelia"){
  data_path <- paste(here(),"/Temporal_Data/",sep = "")
}
if(Sys.info()[7] == "hall1000"){
  data_path <- "/Volumes/DATA/JULIANO_NEYMAR/TransEmergence/Data/"
}


```


# Methods

### Fun `GetSppDist`

This function reads the DBEM data for each year and ensamble (ESM model) from 102 20 111


```{r GetSppDist, eval = T, echo = T}

#### The function
dbem_import <- function(taxon_key,
                        iyr,
                        fyr, 
                        ensamble_list,
                        data_type,
                        Path = NA){
  
  # Creat a sequence of the years to import  
  yr <- seq(iyr,
            fyr,
            by=1) #<- change this setting if you have bi/tri/etc annual data
  
  #### Set the Path####
  #First, set the path of the files under a loop for each year
  
  for(c in 1:length(ensamble_list)){
    
    D_Path <- paste(Path,"mpa0F1ENS",ensamble_list[c],"/", #<- drobo path for 8.5
                    taxon_key,"/",taxon_key,data_type,yr,".txt",
                    sep="")
    
     # total <- NULL
    
    #### Importing data ####
    #Now we import the data using data.table::fread and the path generated above
    
    for (i in 1:length(yr)){ #<-The years you want to have 
      
      possibleError <-  tryCatch({ # <- This will solve for situations where the species is not found in the DBEM
        # Imports dataset 
        cur <- fread(D_Path[i],
                     na.strings = "NA",
                     col.names = c("index",
                                   yr[i]) #<- Calls colunmns by year
        )
        
      },
      error=function(e){ # Part of the "no species in DBEM
        e
      }
      )
      if(!inherits(possibleError, "error")){
        
        # possibleError_I <-  tryCatch({
        #Puts them together in one nice dataset 
        if(i == 1){
          total<- copy(cur) # <- copies the previouse data.table
        }else{ 
          setkey(total, # <- sets the data.table as "reference" ?setkey
                 index); setkey(cur,
                                index); 
          total <- merge(total, #<- Merges all the data in one single file.
                         cur,
                         all = TRUE) # <- This allows for the NA's
          
        } #Close datatable loop 
        
      }
      
    } #First loop END (Path Creation)
    
    # Tidy version
    total <- total %>%
      gather(year,value,-index) %>%
      mutate(taxon_key = taxon_key,
             ensamble=ensamble_list[c])
    
    world_data <- world_grid %>%
      full_join(total,
                by = "index")
    # Messages
    if(inherits(possibleError, "error")){
      
      print(paste("Oops! --> No information for",taxon_key,yr[i], sep = " ")) # <- Display error message
      
    }else{
      
      print(paste("Analysis done for",taxon_key, "ensamble" ,ensamble_list[c]))
    }
    
    
    if(c == 1){
      partial_ensamble <- world_data
    }else{
      spp_ensamble <- bind_rows(partial_ensamble,world_data)
    }
  }
  
  return(spp_ensamble)
  
} #Function end


# Test function (works in Carmelia!)

x <- dbem_import(
  taxon_key <- 600004,
  iyr <- 1951,
  fyr <- 1952,
  data_type <- "Catch",
  # ensamble_list = c(102,103),
  ensamble_list =ensamble_list,
  Path <- DBEM_path
)

unique(x$ensamble)
# head(x)

# Test multiple ensambles and spp

# ensamble_list <- c(102,103)
# taxon_key_list <- c(600004,600005)

# x <- bind_rows(
#   lapply(
#     # taxon_key_list,
#     ensamble_list,
#     FUN= dbem_import,
#     taxon_key = 600004,
#     # ensamble = 102,
#     iyr = 1951,
#     fyr = 1952,
#     data_type = "Abd",
#     Path = paste(data_path,"DBEM/",sep="")
#   )
# )

# OK!

```

## Proportion approach


### Fun `EstPropChange`

```{r EstPropChange, eval = T, echo = F}

EstPropChange <- function(Spp,iyr,fyr,data_type,ensamble_list,Path,Neighbours){
  
  # Get model data from spps
  SppDist <- dbem_import(
    taxon_key = Spp,
    iyr <- iyr,
    fyr <- fyr,
    data_type <- data_type,
    ensamble_list = ensamble_list,
    Path <- Path
  )
  
  # Result 1. Number of Countries that share the species
  
  #____________ Selecting only the transboundary nature of the species _________ #
  Trans_Spp <- SppDist %>%
    left_join(Neighbours,
              by= "index") %>% 
    filter(!is.na(value)) %>% 
    semi_join(Transboundary_spp, # filter only transboundary cases
              by = c("taxon_key","eez_name","eez_neighbour")
    )
  
  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_List <- Neighbours %>% 
    group_by(eez_name,eez_neighbour) %>% 
    summarise(n=n()) %>% 
    ungroup() %>% 
    select(-n)
  
  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(taxon_key,
             eez_name,
             year,
             ensamble) %>% 
    summarise(n_spp_eez = length(unique(index))) %>% 
    left_join(Neighbours_List,
              by = "eez_name") %>% 
    filter(eez_name %in% Trans_Spp$eez_name, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           eez_neighbour %in% Trans_Spp$eez_name)
  
  
  # Step 3. Sum total grids per Neighbours
  
  # Split dataframes to merge latter
  Territory_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      taxon_key,
      Name=eez_name,
      n_spp_eez,
      year,
      ensamble
    )
  
  Neighbour_T <- Spp_Grid %>% 
    ungroup() %>% 
    select(
      taxon_key,
      n_spp_eez,
      Name=eez_neighbour,
      eez_name,
      year,
      ensamble
    )
  
  
  per_change_d <- full_join(Territory_T,
                            Neighbour_T, 
                            by = c("Name","taxon_key","year","ensamble")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(eez_name = Name,
           eez_neighbour =eez_name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(area_index = n_spp_Country/Spp_Total) %>% 
    select(taxon_key,year,ensamble,eez_name,eez_neighbour,area_index) %>% 
    mutate(
      time_step = ifelse(year < 2000,"historical",
                         ifelse(year >= 2045 & year <= 2064, "mid",
                                ifelse(year >= 2080, "n_end","NA")
                         )
      )
    ) %>%
    filter(time_step != "NA") %>% 
    # Time mean and sd
    ungroup() %>% 
    group_by(taxon_key,ensamble,eez_name,eez_neighbour,time_step) %>% 
    summarise_at(vars("area_index"),
                 c(temporal_mean=mean,
                   temporal_sd=sd)
    ) %>% 
    # Ensamble mean and sd
    group_by(taxon_key,eez_name,eez_neighbour,time_step) %>% 
    summarise_at(vars("temporal_mean"),
                 c(ensamble_mean=mean,
                   ensamble_sd=sd)
    ) %>% 
    mutate(ensamble_mean = ifelse(is.na(ensamble_mean),0,ensamble_mean)) %>% 
    select(-ensamble_sd) %>% 
    spread(time_step,ensamble_mean) %>% 
    mutate_at(vars(mid,n_end),
              funs(ifelse(historical == 0 & . == 0, 0, # If for no change than 0
                          ifelse(historical == 0 & . > 0, 100, # If changes from 0 to anything then 100
                                 ((.-historical)/historical)*100 # Estimate percentage
                                 # ((.-historical)/((.historical)/2))*100 # Estimate percentage
                          )
              )
              )
    )
  
  
  #### Statistical test ###
  
  stat_change_d <- full_join(Territory_T,
                             Neighbour_T, 
                             by = c("Name","taxon_key","year","ensamble")
  ) %>%
    rowwise() %>%
    mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
    distinct() %>% # Removes false duplicates from `full_join()`
    rename(eez_name = Name,
           eez_neighbour =eez_name,
           n_spp_Country = n_spp_eez.x,
           n_spp_Neighbour = n_spp_eez.y) %>% 
    mutate(area_index = n_spp_Country/Spp_Total) %>% 
    select(taxon_key,year,ensamble,eez_name,eez_neighbour,area_index) %>% 
    mutate(
      time_step = ifelse(year < 2000,"historical",
                         ifelse(year >= 2045 & year <= 2064, "mid",
                                ifelse(year >= 2080, "n_end","NA")
                         )
      )
    ) 
  
  return(per_change_d)
  
}

```

### Fun `EstTransIndex`


```{r funEstTransIndex, eval= F ,echo = T,warning = F,message = F}

# Function to determine whether or not a species is transboundary

# Varibales needed
# Spp: Species to be analized, data with presence/absence per gridcell
# Index_EEZ: Reference list of all INDEX that fall within EEZs
# EEZ_Size: Number of grid-cells that each EEZ has
# Neighbours: Reference list of neighbouring countries

# Needs getSppDist

#### For testing 
# Spp <- 600004  # Anchovie Equator, Chile and Peru
# Spp <- 600107 # Tuna Many RFMOs
# Spp <- 600004 # Argument 1 must have names (RFMO)
# Spp <- 600464 # Discrete species 
# Spp <- 600051 # One of Pierrs massive (wrong) discrete spp
# x <- c(600464, # Discreat spp in one nation
# 600059, # nowhere to be found spp
# 601352, # Discrete spp in two nations
# 600004) # transboundary spp
# Model <- "All"
# Coord <- CoorG
# 
# # For EEZ
# Neighbours <- Neighbours_Data
# Index_Code <- Index_Code

# __________________________________ #

# The function
EstTransIndex <- function(Spp,iyr,fyr,data_type,ensamble_list,Path,Neighbours){
  
  # Get model data from spps
  SppDist <- dbem_import(
    taxon_key = Spp,
    iyr <- iyr,
    fyr <- fyr,
    data_type <- "Abd",
    ensamble_list = ensamble_list,
    Path <- paste(data_path,"DBEM/",sep="")
  )
  
  # Result 1. Number of Countries that share the species
  
  #____________ Selecting only the transboundary nature of the species _________ #
  Trans_Spp <- SppDist %>%
    left_join(Neighbours,
              by= "index") %>% 
    filter(!is.na(value)) %>% 
    semi_join(Transboundary_spp, # filter only transboundary cases
              by = c("taxon_key","eez_name","eez_neighbour")
    )

  #____________ ESTIMATING DISTRIBUTION INDEX (TRESHOLD 3)_________ #
  # The number of species' cells present within each country's EEZ
  
  #Step 1.  Get EEZ id and Neighbour
  Neighbours_List <- Neighbours %>% 
    group_by(eez_name,eez_neighbour) %>% 
    summarise(n=n()) %>% 
    ungroup() %>% 
    select(-n)
  
  # Step 2. Determines the amount of grids present in each country
  Spp_Grid <- Trans_Spp %>% 
    group_by(taxon_key,
             eez_name,
             year,
             ensamble) %>% 
    summarise(n_spp_eez = length(unique(index))) %>% 
    left_join(Neighbours_List,
              by = "eez_name") %>% 
    filter(eez_name %in% Trans_Spp$eez_name, #Filter out unwanted Neighbours (those who don't have grids within but get included because they are Neighbours)
           eez_neighbour %in% Trans_Spp$eez_name)
  
  
  # Step 3. Sum total grids per Neighbours
  
      # Split dataframes to merge latter
    Territory_T <- Spp_Grid %>% 
      ungroup() %>% 
      select(
        taxon_key,
        Name=eez_name,
        n_spp_eez,
        year,
        ensamble
      )
    
    Neighbour_T <- Spp_Grid %>% 
      ungroup() %>% 
      select(
        taxon_key,
        n_spp_eez,
        Name=eez_neighbour,
        eez_name,
        year,
        ensamble
      )
    
    # Merge dataframes to get totals per Neighbourds
    area_index_d <- full_join(Territory_T,
                              Neighbour_T, 
                              by = c("Name","taxon_key","year","ensamble")
    ) %>%
      rowwise() %>%
      mutate(Spp_Total = sum(n_spp_eez.x,n_spp_eez.y,na.rm=T)) %>% # Total gridcelles per Neighbours
      distinct() %>% # Removes false duplicates from `full_join()`
      rename(eez_name = Name,
             eez_neighbour =eez_name,
             n_spp_Country = n_spp_eez.x,
             n_spp_Neighbour = n_spp_eez.y) %>% 
      mutate(area_index = n_spp_Country/Spp_Total) %>% 
      select(taxon_key,year,ensamble,eez_name,eez_neighbour,area_index) %>% 
      mutate(
        time_step = ifelse(year < 2000,"historical",
                           ifelse(year >= 2045 & year <= 2064, "mid",
                                  ifelse(year >= 2080, "n_end","NA")
                           )
        )
      ) %>%
      # Ensamble mean and sd
      ungroup() %>% 
      group_by(taxon_key,year,eez_name,eez_neighbour,time_step) %>% 
      summarise_at(vars("area_index"),
                   c(ensamble_mean=mean,
                     ensamble_sd=sd)
                   ) %>% 
      group_by(taxon_key,eez_name,eez_neighbour,time_step) %>% #Running mean
      mutate(RMean = rollmean(x = ensamble_mean,
                            5,
                            align = "right",
                            fill = ensamble_mean)
    )
    
    
    
  
    # Determine if changes
    natural_variation_d <- area_index_d %>% 
      ungroup() %>% #remove rowise
      filter(time_step == "historical") %>% 
      # Temporal mean
      group_by(taxon_key,eez_name,eez_neighbour) %>% 
      summarise_at(vars("ensamble_mean"),
                   c(hist_mean_index=mean,
                     hist_sd_index=sd)
      )


    ### Variation treshold
    variation_d <- area_index_d %>% 
      ungroup() %>% #remove rowise
      # Temporal mean
      group_by(taxon_key,time_step,eez_name,eez_neighbour) %>% 
      summarise_at(vars("RMean"),
                   c(mean_index=mean,
                     sd_index=sd)
      ) %>% 
      gather("variable","value",mean_index,sd_index) %>% 
      spread(time_step,value) %>% 
      mutate(larger_variation = ifelse(future > historical,"yes","no"))
      
    
    # William's index methodology
    trans_index_data <- area_index_d %>% 
      left_join(natural_variation_d,
                by = c("taxon_key","eez_name","eez_neighbour")) %>% 
      mutate(d_sd = ensamble_mean/sd_index) %>% 
      gather("variable","value",ensamble_mean:d_sd) %>% 
      ungroup() %>% 
      select(-time_step,-eez_neighbour) %>% 
      rowid_to_column() %>% 
      # spread(time_step,value) %>% 
      spread(eez_name,value) %>% 
      group_by(taxon_key,year,variable) %>% 
      summarise_at(vars("Chile","Ecuador","Peru"),
                   mean,na.rm=T)

    
    ggplot(area_index_d) +
      geom_ribbon(data=area_index_d,
                  aes(
                    x = as.numeric(year),
                    ymin=RMean-ensamble_sd,
                    ymax=RMean+ensamble_sd
                  ),
                  fill = "red",
                  alpha = 0.5
                  )+
      geom_line(
        aes(
          x = as.numeric(year),
          y = RMean
        )
      )  +
      facet_wrap(~eez_name + eez_neighbour,
                 scales = "free")
    
  
} # closes function

# __________________________________
# Test function
# __________________________________

```


### Fun `EstRangeIndex`

```{r load_data_per_ensamble, eval = F, echo = T}

#### Data needed (send to Control pannel latter)

# All ensambles
ensamble_list <- c(102,103)

# for dbem_impo_ensamble So we don't miss INDEX in different ensambles
world_grid <- tibble(index = seq(1,259200,1))
taxon_key <- 600005 #601477


# SAU relations between INDEX and Country's EEZs
EEZIDs_List <- read_excel(paste(data_path,"Spatial/V_Lam/Updated_EEZList_17June2016.xlsx",sep="")) %>% 
  clean_names()
EEZ_CellID <- read_excel(paste(data_path,"Spatial/V_Lam/EEZ_CellID.xlsx",sep="")) %>% 
  clean_names()
colnames(EEZ_CellID) <- c("eezid","index")

Lon_Lat_DBEM <- read.csv("~/GitHub/TransEmergence/Temporal_Data/Spatial/Lon_Lat_DBEM.txt", header=FALSE)
colnames(Lon_Lat_DBEM) <- c("index","lon","lat")

index_code <- EEZIDs_List %>% 
  left_join(EEZ_CellID) %>% 
  rename(eez_name = name) %>% 
  left_join(Lon_Lat_DBEM,
            by = "index")



EstRangeIndex <- function(taxon_key,iyr,fyr,ensamble_list){
  
  spp_data <- dbem_import(
    taxon_key = taxon_key,
    iyr <- 1951,
    fyr <- 2100,
    data_type <- "Abd",
    ensamble_list = ensamble_list,
    Path <- paste(data_path,"DBEM/",sep="")
  ) %>% 
    # Remove places where species is not destributed and set to cero differences between ensambles
    filter(!is.na(value)) %>% 
    spread(ensamble,value) %>% 
    gather(ensamble,value, -1:-3) %>% 
    mutate(value = ifelse(is.na(value),0,value)) %>% 
  # Include eez information
    left_join(index_code,
              by = "index") %>% 
    filter(!is.na(eezid))
  
  # Estimate mean eez centroid
  # centroid_data_eez <-  spp_data %>% 
  #   ungroup() %>% 
  #   group_by(taxon_key,ensamble,year,eezid,eez_name) %>% 
  #   top_n(1,value) %>% 
  #   group_by(year,taxon_key,ensamble,eezid,eez_name) %>% 
  #   summarise_at(vars(lon,lat),mean) %>%  # solves for multiple top 1
  #   rename(eez_centroid_lon = lon,
  #          eez_centroid_lat = lat) %>% 
  #   filter(!is.na(eezid))
  
  
  centroid_data_eez <-  spp_data %>% 
    ungroup() %>% 
    group_by(taxon_key,eezid,eez_name) %>%
    summarise_at(vars(lon,lat),mean) %>%  # solves for multiple top 1
    rename(eez_centroid_lon = lon,
           eez_centroid_lat = lat)
  
  # Visualization of  eez centroids
  # ggplot(spp_data) +
  #   geom_tile(
  #     aes(
  #     x = lon,
  #     y = lat,
  #     fill= eez_name
  #     )
  #   ) +
  #   geom_point(data = centroid_data_eez,
  #              aes(
  #                x = eez_centroid_lon,
  #                y = eez_centroid_lat,
  #                size = 1
  #              )
  #   )
  
  
# Estimate species distribution centroid
  centroid_spp <-  spp_data %>% 
    ungroup() %>% 
    group_by(taxon_key,ensamble,year) %>% 
    top_n(1,value) %>% 
    group_by(taxon_key,ensamble,year) %>% 
    summarise_at(vars(lon,lat),mean) %>%  # solves for multiple top 1
    rename(spp_centroid_lon = lon,
           spp_centroid_lat = lat)
  
  ggplot(centroid_spp) +
    geom_point(
      aes(
        x = spp_centroid_lon,
        y = spp_centroid_lat,
        size = as.numeric(year)#,
        # shape = eez_name
      )
    ) +
    geom_point(data = centroid_data_eez,
               aes(
                 x = eez_centroid_lon,
                 y = eez_centroid_lat,
                 color = eez_name
               )
    ) +
    facet_wrap(~ensamble)
  

# Estimate Transboundary Index
  trans_index_data <- centroid_data_eez %>% 
    left_join(centroid_spp,
              by = c("taxon_key") # removed year
              ) %>% 
    ungroup() %>% 
    # select(year,eez_name,ensamble,spp_centroid_lon,spp_centroid_lat,eez_centroid_lon, eez_centroid_lat) %>%
    rowwise() %>%
    mutate(d_eez = distm(c(eez_centroid_lon, eez_centroid_lat),c(spp_centroid_lon, spp_centroid_lat), fun = distHaversine))
    
trans_index_sd_data <- trans_index_data %>% 
  ungroup() %>% 
  filter(year <2000) %>% 
  group_by(eez_name,ensamble) %>% 
  summarise(
    s_sd = sd(d_eez)
  )

final_trans_index_data <- trans_index_data %>% 
  left_join(trans_index_sd_data,
            by = c("eez_name","ensamble")
            ) %>% 
  mutate(da_dsd = d_eez/s_sd) %>% 
  filter(eez_name != "Colombia (Pacific)") %>% 
  select(year,eez_name,ensamble,da_dsd) %>% 
  spread(eez_name,da_dsd) %>% 
  mutate(Trans_Index = `Mexico (Atlantic)`-`USA (Gulf of Mexico)`/2) %>% 
  ungroup() %>% 
  group_by(ensamble) %>% # Running mean as Kleisner & Pauly 2012
  mutate(RMean = rollmean(x = Trans_Index,
                            5,
                            align = "right",
                            fill = Trans_Index)
    )


ggplot(final_trans_index_data) +
  geom_line(
    aes(
      x = as.numeric(year),
      y = RMean,
      color = ensamble
    )
  ) +
  geom_line(data = final_trans_index_data,
    aes(
      x = as.numeric(year),
      y = Trans_Index,
      color = ensamble
    ),
    linetype = "dashed",
    alpha = 0.5
  ) +
  facet_wrap(~ensamble,
             ncol= 1)

  
  
  # %>% 
  #   filter(ensamble == 102) %>% 
  #   select(year,ensamble,eez_name,d_eez) %>% 
  #   spread(eez_name,d_eez) %>% 
  #   mutate()
  
  

  
  
  
  Year_MCP <-  spp_data %>% 
    # Aggregate MCP per EEZ
    group_by(taxon_key,eezid,eez_name,ensamble,year) %>% 
    summarise(eez_mcp = sum(value,na.rm=T)) %>% 
    # Ensamble mean
    group_by(taxon_key,eezid,eez_name,year) %>% 
    summarise(ensamble_mean = mean(eez_mcp,na.rm=T),
              ensamble_sd = sd(eez_mcp,na.rm=T)
              )
  
  # Test 
  # ggplot(spp_data) +
  #   geom_line(
  #     aes(
  #       x = as.numeric(year),
  #       y = ensamble_mean
  #     )
  #   ) +
  #   geom_point(
  #     aes(
  #       x = as.numeric(year),
  #       y = ensamble_mean+ensamble_sd
  #     )
  #   ) +
  #   geom_point(
  #     aes(
  #       x = as.numeric(year),
  #       y = ensamble_mean-ensamble_sd
  #     )
  #   ) +
  #   facet_wrap(~eez_name)
  
  
  
    
  } # close function

```

## Control Panel

```{r control_panel}


iyr <- 1951
fyr <- 2099
data_type <- "Catch"
ensamble_list <- seq(102,111,1)
DBEM_path <- "/Volumes/DATA/DATA/DBEM/"
world_grid <- tibble(index = seq(1,259200,1))
Neighbours <- read_excel(paste(data_path,"Spatial/EEZ_Neighbour_List.xlsx",sep="")) %>% 
  clean_names()

Transboundary_spp <- read.csv(paste(data_path,"Species/Transboundary_spp.csv",sep="")) %>% clean_names()
  
Spp_list <- unique(Transboundary_spp$taxon_key)[4:5]



```

## Main Routine

```{r main_routine, eval = T, echo = F}

# Problema con 600006

####_______________________ ####
# Estimating proportion change
####_______________________ ####
r_proportion_change <- NULL
# suppressWarnings(
  r_proportion_change <- bind_rows(
    lapply(
      Spp_list, #c(600004,600005),
      EstPropChange,
      iyr <- iyr,
      fyr <- fyr,
      data_type <- "Catch",
      ensamble_list = ensamble_list,
      Path =DBEM_path,
      Neighbours = Neighbours
    )
  )
# )

write_csv(r_proportion_change,
          "r_proportion_change.csv")

```